
%header {: import beaver.Parser; :};

%terminals ID, LPAREN, LBRACE, NULL, SUPER, NEW, MINUS, INTEGER, STRING, BOOLEAN, THIS, IF, WHILE, NOT, RPAREN, TYPE, COLON, VAR, RBRACE, SEMI, ASSIGN, CASE, DEF, NATIVE, COMMA, ARROW, DOT, CLASS, ELSE, EXTENDS, OVERRIDE, LE, LT, EQUALS, TIMES, DIV, PLUS, MATCH;

%class "Parser4Cool";

%goal program;

program
    = classdecl.c                                                {: return new Program(c);   :}
    | classdecl.c program.p                                      {: return new Program(c,p); :}
    ;

classdecl
    = CLASS TYPE varformals.v classbody.c                        {: return new ClassDecl(v,c); :}
    | CLASS TYPE varformals.v EXTENDS TYPE actuals.a classbody.c {: return new ClassDecl(v,a,c); :}
    | CLASS TYPE varformals.v EXTENDS NATIVE classbody.c         {: return new ClassDecl(c,v); :}
    ;

varformals
    = LPAREN RPAREN                                              {: return new EmptyVarFormals(); :}
    | LPAREN VAR ID COLON TYPE RPAREN                            {: return new VarFormals(); :}
    | LPAREN varformals_sub1.v VAR ID COLON TYPE RPAREN          {: return new VarFormals(v); :}
    ;

varformals_sub1
    = VAR ID COLON TYPE COMMA                                    {: return new VarFormalsSub1(); :}
    | varformals_sub1.v VAR ID COLON TYPE COMMA                  {: return new VarFormalsSub1(v); :}
    ;

classbody
    = LBRACE RBRACE                                              {: return new ClassBody(); :}
    | LBRACE feature.f RBRACE                                    {: return new ClassBody(f); :}
    | LBRACE classbody_sub1.c feature.f RBRACE                   {: return new ClassBody(c,f); :}   
    ;

classbody_sub1
    = feature.f                                                  {: return new ClassBodySub1(f); :}
    | classbody_sub1.c feature.f                                 {: return new ClassBodySub1(c,f); :}
    ;

feature
    = feature_sub1.f NATIVE SEMI                                 {: return new NativeFeature(f); :}
    | feature_sub1.f expr.e SEMI                                 {: return new NativeFeature(f,e); :}
    | OVERRIDE feature_sub1.f NATIVE SEMI                        {: return new OverrideFeature(f); :}
    | OVERRIDE feature_sub1.f expr.e SEMI                        {: return new OverrideFeature(f,e); :}
    | feature_sub2.f ASSIGN NATIVE SEMI                          {: return new Feature(f); :}
    | feature_sub2.f COLON TYPE ASSIGN expr.e SEMI               {: return new Feature(f,e); :}
    | LBRACE block.b RBRACE SEMI                                 {: return new Feature(b); :}
    ;  

feature_sub1
    = DEF ID formals.f COLON TYPE ASSIGN                         {: return new FeatureSub1(f); :}
    ;

feature_sub2
    = VAR ID                                                     {: return new FeatureSub2(); :}
    ;

formals
    = LPAREN RPAREN                                              {: return new EmptyFormals(); :}
    | LPAREN ID COLON TYPE RPAREN                                {: return new Formals(); :}
    | LPAREN formals_sub1.f ID COLON TYPE RPAREN                 {: return new Formals(f); :}
    ;

formals_sub1
    = ID COLON TYPE COMMA                                        {: return new FormalsSub1(); :}
    | formals_sub1.f ID COLON TYPE COMMA                         {: return new FormalsSub1(f); :}
    ;

actuals
    = LPAREN RPAREN                                              {: return new Actuals(); :}
    | LPAREN expr.e RPAREN                                       {: return new Actuals(e); :}
    | LPAREN actuals_sub1.a expr.e RPAREN                        {: return new Actuals(a,e); :} 
    ;

actuals_sub1
    = expr.e COMMA                                               {: return new ActualsSub1(e); :}
    | actuals_sub1.a expr COMMA                                  {: return new ActualsSub1(a); :}
    ;

block
    =                                                            {: return new Block(); :}
    | expr.e                                                     {: return new Block(e); :}
    | block_sub1.b expr.e                                        {: return new Block(b,e); :}
    ;


block_sub1
    = expr.e SEMI                                                {: return new SimpleBlockSub1(e); :}
    | block_sub1.b expr.e SEMI                                   {: return new SimpleBlockSub1(b,e); :}
    | VAR ID COLON TYPE ASSIGN expr.e SEMI                       {: return new BlockSub1(e); :}
    | block_sub1.b VAR ID COLON TYPE ASSIGN expr.e SEMI          {: return new BlockSub1(e,b); :}
    ;

expr
    = primary
    | primary expr_sub1
    | expr_sub2 primary
    | expr_sub2 primary expr_sub1
    ;

expr_sub1
    = expr_sub1_1 LPAREN expr RPAREN
    | expr_sub1 expr_sub1_1 LPAREN expr RPAREN
    | MATCH cases
    | expr_sub1 MATCH cases
    | DOT ID actuals
    | expr_sub1 DOT ID actuals
    ;

expr_sub1_1
    = LE
    | LT
    | EQUALS
    | TIMES
    | DIV
    | PLUS
    | MINUS
    ;

expr_sub2
    = ID ASSIGN
    | expr_sub2 ID ASSIGN
    | NOT
    | expr_sub2 NOT
    | MINUS
    | expr_sub2 MINUS
    | IF LPAREN expr RPAREN expr ELSE
    | expr_sub2 IF LPAREN expr RPAREN expr ELSE
    | WHILE LPAREN expr RPAREN
    | expr_sub2 WHILE LPAREN expr RPAREN
    ;

primary
    = ID actuals
    | SUPER DOT ID actuals
    | NEW TYPE actuals
    | LBRACE block RBRACE
    | LPAREN expr RPAREN
    | NULL
    | LPAREN RPAREN
    | ID
    | INTEGER
    | STRING
    | BOOLEAN
    | THIS
    ;

cases
    = LBRACE cases_sub1 RBRACE
    ;

cases_sub1
    = CASE ID COLON TYPE ARROW block
    | cases_sub1 CASE ID COLON TYPE ARROW block
    | CASE NULL ARROW block
    | cases_sub1 CASE NULL ARROW block
    ;

